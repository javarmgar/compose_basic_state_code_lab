package com.example.basicstatecodelab.ui.theme

import android.util.Log
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.padding
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.MutableState
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp

/*
4. Events in Compose
    - what causes the state to update?
        R:  state is updated in response to events.
    - Events: inputs generated from outside or inside an application:
        outside:The user interacting with the UI -> pressing a button.
        inside: A network response

Key idea: State is. Events happen.


UI update loop

Display state -> Event -> update state -> Display State....

    Event: generated by the user or other part
    Update state: Event handler changes the state
    Display State: The Ui is updated to display the new state
 */

/*
5. Memory in a composable function

The Composition: a description of the UI built by Jetpack Compose when it executes composables.
Initial composition: creation of a Composition by running composables the first time.
Recomposition: re-running composables to update the Composition when data changes.

Compose state tracking system:

Compose has -> special state tracking system
 -> schedules recompositions for composables read a state.
 -> Compose be granular
    -> just recompose those composable functions that need to change, not the whole UI.

    This is done by tracking
        not only "writes" (that is, state changes),
        but also "reads" to the state.
 */

/*
 Event though we are observing an state properly and that the recomposition is taking place every time
 the state changes.
 The code  that is executed reinitialize the variable to zero

 Solution: Use an API that stores the value so that next time retrieve the saved value
    Remember API is the answer
 */
@Composable
fun WaterCounter( modifier: Modifier = Modifier) {
    val count: MutableState<Int> = remember { mutableStateOf(0) }
    Column(modifier = modifier.padding(16.dp)) {
        Text(
            text = "Glasses: $count",
        )
        Button(
            modifier = Modifier.padding(top = 16.dp),
            onClick = {
                count.value++
                count.also { Log.d("WaterCounter", "count: ${count.value}") } },
        ) {
            Text(text = "Add one")
        }
    }

}

@Preview(showBackground = true)
@Composable
fun WaterCounterPreview() {
    BasicStateCodelabTheme {
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            WaterCounter()
        }
    }
}